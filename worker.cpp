/**
  * Worker declaration file 
  * copyright: Michael Cueno @ 2013 (mcueno2)
  */

#include "worker.h"

/** Command line arguments: workerID sleepTime msgID shmID [ semID ] workerID: Unique identifier starting at 1 and increasing. Given by parent whom forked this worker
* nBuffers: TODO NOT SURE WHAT THIS DOES 
* sleepTime: time the workers will spend speeping in each work cycle, generated by parent randomly, given in descending order
* msgID/shmID/semID: id for message queue, shared memory block, and semaphore block respectively
*/
int main(int argc, char** argv){
	// Variables 
	int read1;
	int read2; 
	int read3; 

	// Initializations 
	int workerID; int nBuffers; int sleepTime; int msgID; int shmID; int semID;
	parse_input(argc, argv, &workerID, &nBuffers, &sleepTime, &msgID, &shmID, &semID);
	int signature = 1 << (workerID-1);
	int offset; 

	// Part two 
	char content[CONT_MAX];

	// Send start up message 
	sprintf(content, "Worker %d starting up", workerID);
	write_to_msg(msgID, content);

	// Modify shared memory
	int *mem = (int*)shmat(shmID, NULL, 0);
	if(*mem == -1){
		fprintf(stderr, "shmat failed: %s", strerror(errno)); 
	}


	// Begin read/write loop 
	for(int i = 0; i < (3*nBuffers); i++){
		offset = (i * workerID) % nBuffers; 

		if(i%3==0 || i%3==1){     // First and second read operation 
			read1 = *(mem + offset);
			usleep(sleepTime); 
			read2 = *(mem + offset);
			// Error Check 
			if(read1 != read2){
				char buf[CONT_MAX]; 
				sprintf(buf, "RACE COND ERROR: Worker %d in buffer %d. initial: %d final: %d", workerID, offset, read1, read2);
				write_to_msg(msgID, buf); 
			}
		}else{						// Write operation 
			read3 = *(mem + offset); 
			*(mem + offset) = read1 + signature; 
			printf("read3: %d, sig: %d at buf: %d\n", read3, signature, offset);
		}
	}

	// Send finished messege
	sprintf(content, "Worker %d done", workerID);
	write_to_msg(msgID, content);
	return 0;
}

void parse_input(int argc, char** argv, int* workerId, int* nBuffers, int* sleepTime, int* msgID, int* shmID, int* semID){
	if(argc < 6 || argc > 7){
		fprintf(stderr, "%s", "input error in worker! Usage: workerID nBuffers sleepTime msgID shmID [ semID ]\n");
		exit(0);
	}
	*workerId = atoi(argv[1]);
	*nBuffers = atoi(argv[2]);
	*sleepTime = atoi(argv[3]); 
	*msgID = atoi(argv[4]);
	*shmID = atoi(argv[5]);
	if(argc == 7){
		*semID = atoi(argv[6]); 
	}
}

bool write_to_msg(int msgID, char* buf){
	struct msgcontent msgp; 
	strncpy(msgp.content, buf, CONT_MAX);
	int flags = 0; 
	if(msgsnd(msgID, &msgp, sizeof(msgp), flags )<0){
		//fprintf(stderr, "Message send failed with error: %s\n", strerror(errno)); 
		perror("Message Send failure: ");
		exit(-1); 
	} 
}



